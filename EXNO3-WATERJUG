class State:
    def __init__(self, jug1, jug2):
        self.jug1 = jug1
        self.jug2 = jug2

    def __eq__(self, other):
        return self.jug1 == other.jug1 and self.jug2 == other.jug2

    def __hash__(self):
        return hash((self.jug1, self.jug2))

    def __repr__(self):
        return f"({self.jug1}, {self.jug2})"

def pour(jug1, jug2, capacity1, capacity2):
    if jug1 == 0:
        return 0, jug2
    elif jug2 == capacity2:
        return jug1, 0
    else:
        space_left_in_jug2 = capacity2 - jug2
        if jug1 <= space_left_in_jug2:
            return 0, jug1 + jug2
        else:
            return jug1 - space_left_in_jug2, capacity2

def get_neighbors(state, capacity1, capacity2):
    jug1, jug2 = state.jug1, state.jug2
    neighbors = []

    neighbors.append(State(capacity1, jug2))

    neighbors.append(State(jug1, capacity2))

    neighbors.append(State(0, jug2))

    neighbors.append(State(jug1, 0))

    neighbors.append(State(*pour(jug1, jug2, capacity1, capacity2)))

    neighbors.append(State(*pour(jug2, jug1, capacity2, capacity1)))

    return neighbors

def bfs(capacity1, capacity2, target):
    start_state = State(0, 0)
    queue = [(start_state, [])]
    visited = set()

    while queue:
        current_state, path = queue.pop(0)

        if current_state == target:
            return path

        visited.add(current_state)

        for neighbor_state in get_neighbors(current_state, capacity1, capacity2):
            if neighbor_state not in visited:
                queue.append((neighbor_state, path + [neighbor_state]))

    return None

def main():
    capacity1 = 4
    capacity2 = 3
    target = State(2, 0)

    solution = bfs(capacity1, capacity2, target)
    if solution:
        print("Solution Found:")
        print("Initial State: (0, 0)")
        for i, state in enumerate(solution):
            print(f"Step {i + 1}: {state}")
        print("Target State:", target)
    else:
        print("No solution exists.")

if __name__ == "__main__":
    main()
