import heapq

class PuzzleNode:
    def __init__(self, state, parent=None, move=None):
        self.state = state
        self.parent = parent
        self.move = move
        self.g = 0
        self.h = 0

    def __lt__(self, other):
        return (self.g + self.h) < (other.g + other.h)

    def __eq__(self, other):
        return self.state == other.state

    def __hash__(self):
        return hash(str(self.state))


def get_blank_location(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j


def get_manhattan_distance(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                target_row = (state[i][j] - 1) // 3
                target_col = (state[i][j] - 1) % 3
                distance += abs(i - target_row) + abs(j - target_col)
    return distance


def get_neighbors(state):
    i, j = get_blank_location(state)
    neighbors = []
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        if 0 <= i + di < 3 and 0 <= j + dj < 3:
            neighbor_state = [row[:] for row in state]
            neighbor_state[i][j], neighbor_state[i + di][j + dj] = neighbor_state[i + di][j + dj], neighbor_state[i][j]
            neighbors.append(neighbor_state)
    return neighbors


def solve_puzzle(initial_state):
    start_node = PuzzleNode(initial_state)
    start_node.h = get_manhattan_distance(initial_state)
    open_set = [start_node]
    closed_set = set()

    while open_set:
        current_node = heapq.heappop(open_set)
        if current_node.h == 0:
            path = []
            while current_node:
                path.append(current_node.state)
                current_node = current_node.parent
            return path[::-1]
        closed_set.add(current_node)
        for neighbor_state in get_neighbors(current_node.state):
            neighbor_node = PuzzleNode(neighbor_state, current_node)
            neighbor_node.g = current_node.g + 1
            neighbor_node.h = get_manhattan_distance(neighbor_state)
            if neighbor_node not in closed_set:
                heapq.heappush(open_set, neighbor_node)

    return None


initial_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 0, 8]
]

solution = solve_puzzle(initial_state)
if solution:
    print("Solution Found:")
    for i, state in enumerate(solution):
        print("Move", i + 1)
        for row in state:
            print(row)
       
    print("Total number of moves: ",i+1)
else:
    print("No solution found.")
